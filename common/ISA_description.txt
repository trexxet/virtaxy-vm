01: nop                   - do nothing
02: ld reg1, num2         - reg1 = [num2]
03: ld reg1, reg2         - reg1 = [reg2]
04: st num1, num2         - [num1] = num2
05: st num1, reg2         - [num1] = reg2
06: st reg1, num2         - [reg1] = num2
07: st reg1, reg2         - [reg1] = reg2
08: mov reg1, num2        - reg1 = num2
09: mov reg1, reg2        - reg1 = reg2
0A: inc reg1              - reg1 ++
0B: dec reg1              - reg1 --
0C: add reg1, num2        - reg1 += num2
0D: add reg1, reg2        - reg1 += reg2
0E: sub reg1, num2        - reg1 -= num2
0F: sub reg1, reg2        - reg1 -= reg2
10: mul reg1, num2        - reg1 *= num2
11: mul reg1, reg2        - reg1 *= reg2
12: div reg1, num2        - reg1 /= num2
13: div reg1, reg2        - reg1 /= reg2
14: mod reg1, num2        - reg1 %= num2
15: mod reg1, reg2        - reg1 %= reg2
16: and reg1, num2        - reg1 &= num2
17: and reg1, reg2        - reg1 &= reg2
18: nand reg1, num2       - reg1 = reg1 NAND num2
19: nand reg1, reg2       - reg1 = reg1 NAND reg2
1A: or reg1, num2         - reg1 |= num2
1B: or reg1, reg2         - reg1 |= reg2
1C: nor reg1, num2        - reg1 = reg1 NOR num2
1D: nor reg1, reg2        - reg1 = reg1 NOR reg2
1E: xor reg1, num2        - reg1 ^= num2
1F: xor reg1, reg2        - reg1 ^= reg2
20: xnor reg1, num2       - reg1 = reg1 XNOR num2
21: xnor reg1, reg2       - reg1 = reg1 XNOR reg2
22: not reg1              - reg1 = ~reg1
23: shl reg1, num2        - reg1 <<= num2
24: shl reg1, reg2        - reg1 <<= reg2
25: shr reg1, num2        - reg1 >>= num2
26: shr reg1, reg2        - reg1 >>= reg2
27: rtl reg1, num2        - rotate reg1 left by num2
28: rtl reg1, reg2        - rotate reg1 left by reg2
29: rtr reg1, num2        - rotate reg1 right by num2
2A: rtr reg1, reg2        - rotate reg1 right by reg2
2B: push num1             - push num1 to stack
2C: push reg1             - push reg1 to stack
2D: pop                   - pop from stack to void
2E: pop reg1              - pop from stack to reg1
2F: jmp reg1              - unconditional jump at register value
30: jmp num1              - unconditional jump at number
31: bz reg1, reg2         - branch at reg2 if reg1 == 0
32: bz reg1, num2         - branch at num2 if reg1 == 0
33: bnz reg1, reg2        - branch at reg2 if reg1 != 0
34: bnz reg1, num2        - branch at num2 if reg1 != 0
35: be reg1, reg2, reg3   - branch at reg3 if reg1 == reg2
36: be reg1, reg2, num3   - branch at num3 if reg1 == reg2
37: be reg1, num2, reg3   - branch at reg3 if reg1 == num2
38: be reg1, num2, num3   - branch at num3 if reg1 == num2
39: bne reg1, reg2, reg3  - branch at reg3 if reg1 != reg2
3A: bne reg1, reg2, num3  - branch at num3 if reg1 != reg2
3B: bne reg1, num2, reg3  - branch at reg3 if reg1 != num2
3C: bne reg1, num2, num3  - branch at num3 if reg1 != num2
3D: ba reg1, reg2, reg3   - branch at reg3 if reg1 > reg2 (unsigned compare)
3E: ba reg1, reg2, num3   - branch at num3 if reg1 > reg2 (unsigned compare)
3F: ba reg1, num2, reg3   - branch at reg3 if reg1 > num2 (unsigned compare)
41: ba reg1, num2, num3   - branch at num3 if reg1 > num2 (unsigned compare)
42: bb reg1, reg2, reg3   - branch at reg3 if reg1 < reg2 (unsigned compare)
43: bb reg1, reg2, num3   - branch at num3 if reg1 < reg2 (unsigned compare)
44: bb reg1, num2, reg3   - branch at reg3 if reg1 < num2 (unsigned compare)
45: bb reg1, num2, num3   - branch at num3 if reg1 < num2 (unsigned compare)
46: bae reg1, reg2, reg3  - branch at reg3 if reg1 >= reg2 (unsigned compare)
47: bae reg1, reg2, num3  - branch at num3 if reg1 >= reg2 (unsigned compare)
48: bae reg1, num2, reg3  - branch at reg3 if reg1 >= num2 (unsigned compare)
49: bae reg1, num2, num3  - branch at num3 if reg1 >= num2 (unsigned compare)
4A: bbe reg1, reg2, reg3  - branch at reg3 if reg1 <= reg2 (unsigned compare)
4B: bbe reg1, reg2, num3  - branch at num3 if reg1 <= reg2 (unsigned compare)
4C: bbe reg1, num2, reg3  - branch at reg3 if reg1 <= num2 (unsigned compare)
4D: bbe reg1, num2, num3  - branch at num3 if reg1 <= num2 (unsigned compare)
4E: bg reg1, reg2, reg3   - branch at reg3 if reg1 > reg2 (signed compare)
4F: bg reg1, reg2, num3   - branch at num3 if reg1 > reg2 (signed compare)
50: bg reg1, num2, reg3   - branch at reg3 if reg1 > num2 (signed compare)
51: bg reg1, num2, num3   - branch at num3 if reg1 > num2 (signed compare)
52: bl reg1, reg2, reg3   - branch at reg3 if reg1 < reg2 (signed compare)
53: bl reg1, reg2, num3   - branch at num3 if reg1 < reg2 (signed compare)
54: bl reg1, num2, reg3   - branch at reg3 if reg1 < num2 (signed compare)
55: bl reg1, num2, num3   - branch at num3 if reg1 < num2 (signed compare)
56: bge reg1, reg2, reg3  - branch at reg3 if reg1 >= reg2 (signed compare)
57: bge reg1, reg2, num3  - branch at num3 if reg1 >= reg2 (signed compare)
58: bge reg1, num2, reg3  - branch at reg3 if reg1 >= num2 (signed compare)
59: bge reg1, num2, num3  - branch at num3 if reg1 >= num2 (signed compare)
5A: ble reg1, reg2, reg3  - branch at reg3 if reg1 <= reg2 (signed compare)
5B: ble reg1, reg2, num3  - branch at num3 if reg1 <= reg2 (signed compare)
5C: ble reg1, num2, reg3  - branch at reg3 if reg1 <= num2 (signed compare)
5D: ble reg1, num2, num3  - branch at num3 if reg1 <= num2 (signed compare)
5E: call reg1             - call function at reg1
5F: call num1             - call function at num1
60: ret                   - return from function
61: in reg1               - get terminal input (using scanf) and write to reg1
62: out reg1              - print reg1 to terminal
63: dump                  - dump everything for debug
